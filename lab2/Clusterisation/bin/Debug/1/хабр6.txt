Неопределенное поведение в C++ из песочницы
C++*
Достаточно сложной темой для программистов на С++ является undefined behavior. Даже опытные разработчики зачастую не могут четко сформулировать причины его возникновения. Статья призвана внести чуть больше ясности в этот вопрос.

Статья является ПЕРЕВОДОМ нескольких статей и выдержек из Стандарта по данной теме.

Что такое «точки следования»?

Стандарте сказано:
Точки следования (sequence points)– такие точки в процессе выполнения программы, в которых все побочные эффекты уже выполненного кода закончили свое действие, а побочные эффекты кода, подлежащего исполнению, еще не начали действовать. (§1.9/7)


Побочные эффекты? А что такое «побочные эффекты»?

Побочный эффект (side effect) (согласно Стандарту) – результат доступа к volatile объекту, изменения объекта, вызова функции из библиотеки I/O или же вызова функции, включающей в себя какие-то из этих действий. Побочный эффект является изменением состояния среды выполнения.

Вычисление некоторого выражения дает на выходе какой-то результат. Если же в дополнение к результату вычисление выражения вызывает изменения в среде выполнения, то говорят, что данное выражение имеет побочные эффекты.

Например:

int x = y++;   //  «y» тоже int


В дополнение к операции инициализации переменной «x» значение переменной «y» изменилось из-за побочного эффекта оператора ++.
Что ж, с этим понятно. Далее к точкам следования. Альтернативное определение понятия «точка следования» дано Стивом Саммитом (автор книг «Язык C в вопросах и ответах», блога «comp.lang.c»):
Точка следования – момент времени, когда «пыль улеглась», и все встреченные побочные эффекты гарантированно завершены и остались позади.

Какие точки следования описаны в Стандарте C++?

В стандарте описаны следующие точки следования:

в конце вычисления полного выражения (§1.9/16). Под «полным выражением» (full-expression) подразумевается выражение, не являющееся подвыражением (subexpression) — частью другого выражения (прим: вычисление полного выражения может включать в себя вычисление подвыражения, лексически не являющегося его частью. Например, подвыражения, участвующие в вычислении аргумента по умолчанию, считаются частью выражения, которое вызвало функцию, а не выражения, определяющего этот аргумент). 

Например:

int a = 5; // «;» - точка следования в данном контексте


в вычислении следующих выражений, а именно после вычисления первого операнда:

1. a && b (§5.14)
2. a || b (§5.15)
3. a? b: c (§5.16)
4. a, b ($5.18) 

Вычисление этих выражений идет слева направо. После вычисления левого подвыражения все побочные эффекты этого вычисления прекращают действие. Если после вычисления левого подвыражения значение полного выражения известно, то правая часть не вычисляется. В последнем случае имеется в виду оператор запятая. В функции func(a, a++) запятая – не оператор, а просто разделитель между аргументами.

при вызове функции (неважно, является функция встроенной или нет) после вычисления всех ее аргументов (если таковые имеются) и перед выполнением каких-либо инструкций в ее теле.


Что такое «неопределенное поведение»?

Стандарт дает определение словосочетанию «неопределенное поведение» в §1.3.12:
Неопределенное поведение (undefined behavior)– поведение, которое может возникать в результате использования ошибочных программных конструкций или некорректных данных, на которые Международный Стандарт не налагает никаких требований. Неопределенное поведение также может возникать в ситуациях, не описанных в Стандарте явно.

Иными словами, неопределенное поведение означает что угодно, что может произойти, начиная от козявки, выпавшей из носа, заканчивая беременностью вашей девушки.

Какая связь между неопределенным поведением и точками следования?

Перед тем, как узнать ответ на этот вопрос, вы должны понять, в чем различия между неопределенным поведением, неуточняемым поведением и поведением, определяемым реализацией. 
Неуточняемое поведение (unspecified behavior) (согласно Стандарту) – поведение, для которого Стандарт предлагает два или более возможных вариантов и не налагает четких требований на то, какой из них должен быть выбран в определенной ситуации.

Неуточняемое поведение возникает в результате вычисления таких подвыражений, как:
аргументы в вызове функции
операнды операторов (напр. +, -, =, *, /), за исключением: 
операторов бинарной логики (&& и ||)
оператора условия (?:)
оператора запятой.

(прим.: за исключением именно тех операторов, которые содержат точку следования)

Поведение, определяемое реализацией (implementation-defined behavior) (согласно Стандарту) – поведение правильно сформированной программной конструкции с правильными данными, которое зависит от реализации (должно быть документировано для каждой реализации).

Пример такого поведения – размер указателя. В соответствии со Стандартом, размер указателя зависит от конкретной реализации компилятора. В рамках одной конкретной реализации размер указателей различных типов также может быть различным.
Также хочу отметить, что порядок вычисления операндов конкретного оператора, подвыражений конкретного выражения, и порядок возникновения побочных эффектов не уточнены.

Например:

int x = 5, y = 6;
int z = x++ + y++; // не уточнено, будет вычислен первым x++ или y++ 


Еще один пример:


  int Hello()
  {
       return printf("Hello"); 
  }

  int World()
  {
       return printf("World !");
  }

  int main()
  {

      int a = Hello() + World(); /**может вывести «Hello World!» или «World! Hello»
                      ^
                      | 
                Функции могут быть вызваны в любом порядке **/
      return 0;
  } 


В §5/4 Стандарт говорит: 
Между двумя точками следования скалярный объект должен менять хранимое значение при вычислении выражения не более одного раза.

Что это значит?

Говоря чуть проще, переменную между двумя точками следования нельзя менять больше одного раза. В выражении следующая точка следования обычно располагается на заключающей точке с запятой, а предыдущая – в конце предшествующего оператора. Выражение так же может содержать промежуточные точки следования.
Исходя из вышесказанного, следующие выражения создают неопределенное поведение:


i++ * ++i; // 
i = ++i;   // 
++i = 2;   //    i изменено более 1 раза
i = ++i +1 // 
i = (i,++i,++i); // нет точки следования между правым `++i` и присвоением `i` (`i` изменяется более 1 раза между 2мя точками следования)  

Но в то же время:


i = (i, ++i, 1) + 1; // определено
i = (++i,i++,i)     //  определено
int j = i;
j = (++i, i++, j*i); // определено 


Кроме того (по Стандарту) – старое значение выражения (до вычисления) должно быть доступно только для определения хранимого значения. 
Это значит, что некорректными являются те выражения, в которых доступ к значению может предшествовать его модификации. 

Например:


std::printf("%d %d", i,++i); // неизвестно, что произойдет раньше – вычисление (++i) или доступ к нему.


Еще один пример:


a[i] = i++ ;   // либо a[++i] = i , либо  a[i++] = ++i  и т.д. 


Я слышал, что в C++0x нет никаких Точек Следования, это правда?


Да, это правда.
Понятие «точка следования» было заменено комитетом ISO C++ на уточненное и дополненное понятие Отношения Следования [ДО\ПОСЛЕ]. 

Что такое Отношение Следования[ДО]?
Следование ДО (Sequenced Before) это отношение, которое:
ассиметрично
транзитивно
возникает между парами вычислений и формирующее из них частично упорядоченное множество (partially ordered set)


Формально, это означает, что при двух данных выражениях А и B, если А [следует ДО] B, то выполнение А должно предшествовать выполнению В. Если же А не [следует ДО] В, тогда выполнение А и В является неупорядоченным (unsequenced) (выполнение неупорядоченных вычислений может пересекаться). 
Вычисление A и В являются неопределенно упорядоченным (indeterminantly sequenced), когда либо А [следует ДО] В, либо В [следует ДО] А, но что именно – не уточнено. Неопределенно упорядоченные вычисления не могут пересекаться, но любое из них может выполнятся первым.

Что означает слово «вычисление» в контексте C++0x ?

В С++0x вычисление (evaluation) выражения (или подвыражения) в общем случае включает в себя:
подсчет (computation) значения (включая определение положения объекта в памяти для вычисления значения gvalue-выражения и получение значения по ссылке для вычисления prvalue-выражения)
инициирование побочных эффектов


Стандарт говорит нам (§1.9/14): 
Каждый подсчет значения и побочный эффект, связанные с полным выражением, [следуют ДО] подсчета значения и побочного эффекта, связанных со следующим полным выражением, которое будет вычислено.

Тривиальный пример:

int x;  x = 10;  ++x; 


В данном примере подсчет значения и побочный эффект, связанный с выражением (++x), [следует ПОСЛЕ] подсчета значения и побочного эффекта (x=10).

Ведь между вещами, описанными выше, и неопределенным поведением должна быть какая-то связь, да?


Конечно, связь есть.

В §1.9/15 упоминается, что:
Вычисление операндов конкретного оператора или подвыражений конкретного выражения неупорядоченно, помимо случаев, которые были описаны ранее.

Примечание: неупорядоченные и неопределенно упорядоченные подвыражения полного выражения, которое вычисляется более одного раза в процессе выполнения программы, не обязательно вычисляются каждый раз в одном и том же порядке.

Например:


int main()
{
     int num = 19 ;
     num = (num << 3) + (num >> 3) ;
} 


1) Вычисление операндов оператора «+» неупорядоченно.
2) Вычисление операндов операторов «<<» и «>>» неупорядоченно.

§1.9/15 подсчет значения операндов конкретного оператора [следует ДО] подсчета значения результата работы оператора.

Это означает, что в выражении x + y подсчет значений «х» и «у» [следует ДО] подсчета x+y.

Теперь к более важному:

§1.9/15 Если возникновение побочного эффекта скалярного объекта неупорядоченно по отношению к одному из следующий событий:
возникновению другого побочного эффекта этого же объекта
подсчету значения с использованием значения этого объект

то поведение программы будет НЕОПРЕДЕЛЕННЫМ.


Пример:

f(i  =  -1,  i  =  -1);


При вызове функции каждый подсчет значения и побочный эффект, связанный с выражением аргумента этой функции, или с выражением, вызывающим функцию, [следует ДО] выполнения любого выражения или оператора в теле вызываемой функции. 
Подсчет значения и побочные эффекты, связанные с разными аргументами, неупорядоченны.

Поток выполнения программы


Оперируя терминами, расшифрованными ранее, поток выполнения программы можно представить графически. В следующих далее диаграммах обозначим вычисление выражения (или подвыражения) как E(x), точку следования — %, побочный эффект «k» для объекта «e» обозначим S(k,e). Если для вычисления необходимо считать значение из именованного объекта (пусть «x» — имя), вычисление будем обозначать V(x), в остальных случаях – так же, как договаривались ранее, E(x). Побочные эффекты запишем справа и слева от выражений. Граница между двумя выражениями обозначает, что верхнее выражение вычисляется до нижнего выражения (зачастую потому что нижнее выражение зависит от prvalue или lvalue верхнего выражения). 
Для двух выражений i++; i++; диаграмма будет иметь вид:

E(i++) -> { S(increment, i) }
   |
   %
   |
E(i++) -> { S(increment, i) }
   |
   % 


Как видите, в данном случае мы имеем две точки следования, одна из которых разделяет два изменения «i».
Вызовы функций также представляют интерес, несмотря на то, что диаграмму для них мы опустим:


int c = 0;
int d = 0;
void f(int a, int b) { assert((a == c - 1) && (b == d - 1)); }
int main() { f(c++, d++); } 


Этот код корректный, потому что к тому времени, как начнет выполняться тело функции f, все побочные эффекты, порожденные вычислением аргументов, гарантированно закончатся: «с» и «d» будут увеличены на 1.
Теперь рассмотрим выражение i++ * j++;
{ S(increment, i) } <- E(i++)      E(j++) -> { S(increment, j) }
                           \       /
                            +--+--+
                               |
                         E(i++ * j++)
                               |
                               % 


Откуда же появилось две ветки? Напомним, что точки следования завершают вычисления, проводившиеся ДО их наступления. Все подвыражения умножения вычисляются до самого умножения, больше в этом выражении нет точки следования, следовательно, нам нужно принять во внимание теоретическую «параллельность» вычисления операндов, чтобы предположить, где может произойти конкурентное изменение одного и того же объекта. Говоря более формально, эти две ветви неупорядочены. Точки следования – это отношение, которое упорядочивает некоторые вычисления и не упорядочивает другие. Т.о. точки следования, как и говорилось выше, являются частичным упорядочиванием (partial order). 

Конфликтующие побочные эффекты.

Чтобы обеспечить компилятору свободу в генерации и оптимизации машинного кода, в случаях, подобных рассмотренному выше умножению, не устанавливается порядок вычисления подвыражений и не разделяются побочные эффекты, порожденные ими (за исключением описанных ранее случаев).
Это может вести к конфликтам, поэтому Стандарт называет неопределенным поведение программы, если она пытается модифицировать один и тот же объект без участия точек следования. Это относится к скалярным объектам, потому что остальные объекты являются либо неизменяемыми (array) или попросту не подпадают под это правило (class objects). Неопределенное поведение также возникает, если в выражении присутствуют обращение к предыдущему значению объекта и его модификация, как например в i * i++ 
// Ведет к неопределенному поведению!
// Не факт, что из левого 'i' будет считано «новое» значение:

    V(i)        E(i++) -> { S(increment, i) })
      \         /
       +---+---+
           |
       E(i * i++)
           |
           %

В качестве исключения позволено считывать значение объекта, если оно необходимо для подсчета нового значения. Пример контекста: i = i+1
                V(i)        E(1)
                   \         /
                    +---+---+
                        |
  E(i)              E(i + 1)
     \                 /
      +-------+-------+
              |
        E(i = i + 1) -> { S(assign, i) }
              |
              %


Здесь мы видим обращение к «i» в правой части; после вычисления обеих частей совершается присваивание. Т.о. побочный эффект и обращение к «i» происходят, не пересекая точку следования, но обращались к «i» мы только для определения хранимого значения, поэтому разногласий не будет. 
Иногда, значение считывается после модификации. Для случая
a = (b = 0);
справедливо, что происходит запись в «b», а потом чтение из «b» без пересечения точки следования. Тем не менее, это нормально, потому что считывается уже новое значение «b», а обращения к старому не происходит. В этом случае побочные эффекты присвоения «b» закончат свое действие не только до следующей точки следования, но и перед чтением значения «b», требуемого для присвоения «а». Стандарт явно говорит: «результатом операции присваивания является значение, хранимое в левом операнде, после того, как присваивание выполнено (результат — lvalue)». Почему не используется понятие точки следования? Потому что это понятие содержит ненужное в данной ситуации требование, чтобы все побочные эффекты левого и правого операнда были завершены, вместо того чтобы рассматривать только побочные эффекты присвоения, возвращающего lvalue, с помощью которого происходит считывание.

Источники:
Актуальная версия стандарта
stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points?lq=1
stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior
undefined behavior, sequence points